<!DOCTYPE html>
<!--
MIT License

Copyright (c) 2025 bon-soleil

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

---

This project includes code from the following third-party libraries:

1. **lit (by Google LLC)**
   License: BSD 3-Clause

   Copyright 2017 Google LLC
   SPDX-License-Identifier: BSD-3-Clause

   https://github.com/lit/lit/blob/main/LICENSE

2. **Three.js**
   License: MIT License

   Copyright 2010-2024 Three.js Authors
   SPDX-License-Identifier: MIT


-->
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>3D Model Viewer</title>
    <script type="module" src="./model-viewer.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Oxygen, Ubuntu, Cantarell, sans-serif;
        background-color: #000000;
        margin: 0;
        padding: 0;
        overflow: hidden;
        position: fixed;
        width: 100%;
        height: 100%;
        /* ãƒ¢ãƒã‚¤ãƒ«ãƒ–ãƒ©ã‚¦ã‚¶ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ãƒãƒ¼ã‚’è€ƒæ…® */
        height: 100vh;
        height: -webkit-fill-available;
      }
      
      /* iOSã®ã‚»ãƒ¼ãƒ•ã‚¨ãƒªã‚¢å¯¾å¿œ */
      @supports (padding: env(safe-area-inset-top)) {
        body {
          padding-top: env(safe-area-inset-top);
          padding-bottom: env(safe-area-inset-bottom);
          padding-left: env(safe-area-inset-left);
          padding-right: env(safe-area-inset-right);
        }
      }

      .container {
        position: relative;
        width: 100%;
        height: 100%;
        background-color: #000000;
      }

      model-viewer {
        width: 100%;
        height: 100%;
        --poster-color: #000000;
        --progress-bar-color: #007bff;
        --progress-mask: transparent;
        display: block;
        background-color: var(--poster-color);
      }

      /* ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ */
      .custom-progress-bar {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.95);
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      }

      .progress-text {
        font-size: 14px;
        color: #333;
        font-weight: 500;
      }

      .progress-bar-track {
        width: 200px;
        height: 6px;
        background-color: rgba(0, 0, 0, 0.1);
        border-radius: 3px;
        overflow: hidden;
      }

      .progress-bar-fill {
        height: 100%;
        background: linear-gradient(90deg, #007bff, #0056b3);
        border-radius: 3px;
        transition: width 0.3s ease;
        animation: progressPulse 1.5s ease-in-out infinite;
        width: 0%;
      }

      .progress-percent {
        font-size: 12px;
        color: #666;
        font-weight: 500;
      }

      @keyframes progressPulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.7;
        }
      }

      /* ãƒ©ã‚¤ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ */
      .light-control-button {
        position: absolute;
        top: 15px;
        right: 15px;
        width: 30px;
        height: 30px;
        border: none;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.9);
        cursor: pointer;
        z-index: 100;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        transition: all 0.2s ease;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .light-control-button svg {
        width: 21px;
        height: 21px;
        fill: #333;
      }

      .light-control-button:hover {
        background: rgba(255, 255, 255, 1);
        transform: scale(1.1);
      }

      /* ãƒ©ã‚¤ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« */
      .light-controls {
        position: absolute;
        top: 15px;
        right: 50px;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 8px;
        padding: 15px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        z-index: 100;
        min-width: 200px;
        display: none;
      }

      .control-group {
        margin-bottom: 12px;
      }

      .control-group:last-child {
        margin-bottom: 0;
      }

      .control-label {
        display: block;
        font-size: 12px;
        font-weight: 500;
        color: #333;
        margin-bottom: 5px;
      }

      .slider {
        width: 100%;
        height: 4px;
        border-radius: 2px;
        background: #ddd;
        outline: none;
        -webkit-appearance: none;
      }

      .slider::-webkit-slider-thumb {
        -webkit-appearance: none;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .slider::-moz-range-thumb {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background: #007bff;
        cursor: pointer;
        border: none;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      }

      .preset-buttons {
        display: flex;
        gap: 5px;
        margin-top: 10px;
      }

      .preset-button {
        flex: 1;
        padding: 6px 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: white;
        font-size: 11px;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .preset-button:hover {
        background: #f0f0f0;
        border-color: #007bff;
      }

      /* èƒŒæ™¯åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³ */
      .background-toggle {
        display: flex;
        gap: 8px;
        align-items: center;
      }

      .bg-button {
        width: 32px;
        height: 32px;
        border: 2px solid #ddd;
        border-radius: 50%;
        background: transparent;
        font-size: 16px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: all 0.2s ease;
      }

      .bg-button.active {
        border-color: #007bff;
        box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.2);
      }

      .bg-button:hover {
        border-color: #007bff;
        transform: scale(1.1);
      }

      .bg-black {
        background: #000;
      }

      .bg-white {
        background: #fff;
        border-color: #ccc;
      }

      .bg-white.active {
        border-color: #007bff;
      }

      /* ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ’ãƒ³ãƒˆ */
      .controls-hint {
        position: absolute;
        bottom: 10px;
        left: 10px;
        right: 10px;
        background: rgba(0, 0, 0, 0.7);
        color: white;
        padding: 8px 12px;
        border-radius: 6px;
        font-size: 12px;
        text-align: center;
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .container:hover .controls-hint {
        opacity: 1;
      }

      .controls-hint p {
        margin: 0;
        opacity: 0.9;
      }
      
      /* ã‚»ãƒ³ã‚¿ãƒ¼ãƒœã‚¿ãƒ³ã®ãƒ›ãƒãƒ¼åŠ¹æœ */
      .center-button:hover {
        background: rgba(255, 255, 255, 1);
        transform: scale(1.1);
      }
      
      /* æœ€å¤§åŒ–ãƒœã‚¿ãƒ³ã®ãƒ›ãƒãƒ¼åŠ¹æœ */
      .maximize-button:hover {
        background: rgba(255, 255, 255, 1);
        transform: scale(1.1);
      }

      /* ã‚¨ãƒ©ãƒ¼è¡¨ç¤º */
      .error-display {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
        min-height: 300px;
        padding: 40px 20px;
        text-align: center;
        background: rgba(255, 255, 255, 0.95);
        border-radius: 12px;
        position: relative;
      }

      .error-icon {
        font-size: 48px;
        margin-bottom: 16px;
      }

      .error-text {
        max-width: 400px;
      }

      .error-title {
        font-size: 18px;
        font-weight: 600;
        color: #dc3545;
        margin: 0 0 8px 0;
      }

      .error-message {
        font-size: 14px;
        color: #666;
        margin: 0 0 20px 0;
        line-height: 1.4;
      }

      .viewer-link {
        display: inline-block;
        padding: 8px 16px;
        background-color: #007bff;
        color: white;
        text-decoration: none;
        border: none;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      .viewer-link:hover {
        background-color: #0056b3;
        color: white;
        text-decoration: none;
      }

      /* ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ */
      @media (max-width: 768px) {
        .light-controls {
          right: 10px;
          top: 55px;
          min-width: 180px;
        }
        
        /* ãƒ¢ãƒã‚¤ãƒ«ã§ã¯ãƒœã‚¿ãƒ³ã‚’å°‘ã—å†…å´ã«é…ç½® */
        .maximize-button {
          top: calc(15px + env(safe-area-inset-top)) !important;
          left: calc(15px + env(safe-area-inset-left)) !important;
        }
        
        .center-button {
          top: calc(15px + env(safe-area-inset-top)) !important;
          right: calc(60px + env(safe-area-inset-right)) !important;
        }
        
        .light-control-button {
          top: calc(15px + env(safe-area-inset-top)) !important;
          right: calc(15px + env(safe-area-inset-right)) !important;
        }
      }
      
      /* ã‚¨ãƒ©ãƒ¼ã‚¹ãƒ”ãƒŠãƒ¼ */
      .error-spinner {
        width: 40px;
        height: 40px;
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid #fff;
        border-radius: 50%;
        margin: 0 auto;
        animation: spin 1s linear infinite;
      }
      
      @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
      }
      
      /* ãƒ¡ã‚¿ãƒã‚¹ã‚¯ç”¨ã®å¹ãå‡ºã— */
      .metamask-hint {
        position: absolute;
        bottom: 20px;
        right: 20px;
        background: #007bff;
        color: white;
        padding: 12px 16px;
        border-radius: 8px;
        font-size: 13px;
        max-width: 250px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3), 0 8px 24px rgba(0, 0, 0, 0.2);
        animation: pulseHint 2s ease-in-out infinite;
      }
      
      .metamask-hint::after {
        content: '';
        position: absolute;
        bottom: -8px;
        right: 30px;
        width: 0;
        height: 0;
        border-left: 8px solid transparent;
        border-right: 8px solid transparent;
        border-top: 8px solid #007bff;
      }
      
      @keyframes pulseHint {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <!-- ãƒ¢ãƒ‡ãƒ«ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼ -->
      <model-viewer
        id="modelViewer"
        alt="goodsun | bon-soleil"
        camera-controls
        loading="eager"
        reveal="auto"
        exposure="0.7"
        shadow-intensity="0.7"
        shadow-softness="0.3"
        style="--poster-color: #000000; background-color: #000000"
        camera-orbit="0deg 75deg 105%"
        field-of-view="30deg"
        min-camera-orbit="auto auto auto"
        max-camera-orbit="auto auto auto"
        min-field-of-view="10deg"
        max-field-of-view="45deg"
        autoplay
        animation-crossfade-duration="300ms"
      >
        <!-- ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ã‚’ç„¡åŠ¹åŒ– -->
        <div slot="progress-bar"></div>

        <!-- ã‚«ã‚¹ã‚¿ãƒ ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼ -->
        <div class="custom-progress-bar" id="customProgressBar">
          <div class="progress-text">Loading 3D Model...</div>
          <div class="progress-bar-track">
            <div class="progress-bar-fill" id="progressBarFill"></div>
          </div>
          <div class="progress-percent" id="progressPercent">0%</div>
        </div>
      </model-viewer>

      <!-- æœ€å¤§åŒ–ãƒœã‚¿ãƒ³ -->
      <a
        href=""
        target="_blank"
        class="maximize-button"
        id="maximizeButton"
        title="Open in New Window"
        style="position: absolute; top: 15px; left: 15px; width: 30px; height: 30px; border: none; border-radius: 50%; background: rgba(255, 255, 255, 0.9); cursor: pointer; z-index: 100; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); transition: all 0.2s ease; display: flex; align-items: center; justify-content: center; text-decoration: none;"
      >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="width: 18px; height: 18px; fill: #333;">
          <!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->
          <path d="M320 0c-17.7 0-32 14.3-32 32s14.3 32 32 32l82.7 0L201.4 265.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0L448 109.3l0 82.7c0 17.7 14.3 32 32 32s32-14.3 32-32l0-160c0-17.7-14.3-32-32-32L320 0zM80 32C35.8 32 0 67.8 0 112L0 432c0 44.2 35.8 80 80 80l320 0c44.2 0 80-35.8 80-80l0-320c0-17.7-14.3-32-32-32s-32 14.3-32 32l0 320c0 8.8-7.2 16-16 16L80 448c-8.8 0-16-7.2-16-16l0-320c0-8.8 7.2-16 16-16l224 0c17.7 0 32-14.3 32-32s-14.3-32-32-32L80 32z"/>
        </svg>
      </a>

      <!-- ã‚»ãƒ³ã‚¿ãƒ¼ãƒœã‚¿ãƒ³ -->
      <button
        class="center-button"
        id="centerButton"
        title="Center Model"
        style="position: absolute; top: 15px; right: 60px; width: 30px; height: 30px; border: none; border-radius: 50%; background: rgba(255, 255, 255, 0.9); cursor: pointer; z-index: 100; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2); transition: all 0.2s ease; display: flex; align-items: center; justify-content: center;"
      >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" style="width: 18px; height: 18px; fill: #333;">
          <!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->
          <path d="M256 0c17.7 0 32 14.3 32 32l0 34.7C368.4 80.1 431.9 143.6 445.3 224l34.7 0c17.7 0 32 14.3 32 32s-14.3 32-32 32l-34.7 0C431.9 368.4 368.4 431.9 288 445.3l0 34.7c0 17.7-14.3 32-32 32s-32-14.3-32-32l0-34.7C143.6 431.9 80.1 368.4 66.7 288L32 288c-17.7 0-32-14.3-32-32s14.3-32 32-32l34.7 0C80.1 143.6 143.6 80.1 224 66.7L224 32c0-17.7 14.3-32 32-32zM128 256a128 128 0 1 0 256 0 128 128 0 1 0 -256 0zm128-80a80 80 0 1 1 0 160 80 80 0 1 1 0-160z"/>
        </svg>
      </button>

      <!-- ãƒ©ã‚¤ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ -->
      <button
        class="light-control-button"
        id="lightControlButton"
        title="Light Controls"
      >
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512">
          <!--!Font Awesome Free 6.7.2 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2025 Fonticons, Inc.-->
          <path
            d="M272 384c9.6-31.9 29.5-59.1 49.2-86.2c0 0 0 0 0 0c5.2-7.1 10.4-14.2 15.4-21.4c19.8-28.5 31.4-63 31.4-100.3C368 78.8 289.2 0 192 0S16 78.8 16 176c0 37.3 11.6 71.9 31.4 100.3c5 7.2 10.2 14.3 15.4 21.4c0 0 0 0 0 0c19.8 27.1 39.7 54.4 49.2 86.2l160 0zM192 512c44.2 0 80-35.8 80-80l0-16-160 0 0 16c0 44.2 35.8 80 80 80zM112 176c0 8.8-7.2 16-16 16s-16-7.2-16-16c0-61.9 50.1-112 112-112c8.8 0 16 7.2 16 16s-7.2 16-16 16c-44.2 0-80 35.8-80 80z"
          />
        </svg>
      </button>

      <!-- ãƒ©ã‚¤ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ« -->
      <div class="light-controls" id="lightControls">
        <div class="control-group">
          <label class="control-label">
            Brightness: <span id="exposureValue">70</span>%
          </label>
          <input
            type="range"
            min="0.1"
            max="2.0"
            step="0.1"
            value="0.7"
            id="exposureSlider"
            class="slider"
          />
        </div>

        <div class="control-group">
          <label class="control-label">
            Shadow: <span id="shadowValue">70</span>%
          </label>
          <input
            type="range"
            min="0"
            max="2.0"
            step="0.1"
            value="0.7"
            id="shadowSlider"
            class="slider"
          />
        </div>

        <div class="control-group">
          <label class="control-label">Background</label>
          <div class="background-toggle">
            <button
              id="bgBlackBtn"
              class="bg-button bg-black active"
              title="Black background"
            >
              âš«
            </button>
            <button
              id="bgWhiteBtn"
              class="bg-button bg-white"
              title="White background"
            >
              âšª
            </button>
          </div>
        </div>

        <div class="preset-buttons">
          <button class="preset-button" onclick="setPreset(0.5, 0.3)">
            Dim
          </button>
          <button class="preset-button" onclick="setPreset(0.7, 0.7)">
            Normal
          </button>
          <button class="preset-button" onclick="setPreset(1.5, 1.2)">
            Bright
          </button>
        </div>
      </div>

      <!-- ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ’ãƒ³ãƒˆ -->
      <div class="controls-hint">
        <p>Drag to rotate â€¢ Scroll to zoom â€¢ Right-click to pan</p>
      </div>
    </div>

    <script>
      const modelViewer = document.getElementById("modelViewer");
      const lightControlButton = document.getElementById("lightControlButton");
      const lightControls = document.getElementById("lightControls");
      const customProgressBar = document.getElementById("customProgressBar");
      const progressBarFill = document.getElementById("progressBarFill");
      const progressPercent = document.getElementById("progressPercent");
      const exposureSlider = document.getElementById("exposureSlider");
      const shadowSlider = document.getElementById("shadowSlider");
      const exposureValue = document.getElementById("exposureValue");
      const shadowValue = document.getElementById("shadowValue");
      const bgBlackBtn = document.getElementById("bgBlackBtn");
      const bgWhiteBtn = document.getElementById("bgWhiteBtn");
      const centerButton = document.getElementById("centerButton");

      let showControls = false;
      let currentBackgroundColor = "black";

      // ãƒ©ã‚¤ãƒˆã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ã®è¡¨ç¤º/éè¡¨ç¤º
      lightControlButton.addEventListener("click", () => {
        showControls = !showControls;
        lightControls.style.display = showControls ? "block" : "none";
      });
      
      // ãƒ¢ãƒ‡ãƒ«ã‚’ã‚»ãƒ³ã‚¿ãƒ¼ã«é…ç½®ã™ã‚‹é–¢æ•°
      function centerModel() {
        if (!modelViewer || !modelViewer.loaded) {
          console.log("Model not loaded yet");
          return;
        }
        
        // ç¾åœ¨ã®ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’å–å¾—
        const currentOrbit = modelViewer.getCameraOrbit();
        console.log("Current camera orbit:", currentOrbit);
        
        // ãƒ¢ãƒ‡ãƒ«ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã®ä¸­å¿ƒã‚’å–å¾—
        const bounds = modelViewer.getBoundingBoxCenter();
        console.log("Model bounds center:", bounds);
        
        // ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã®ä¸­å¿ƒã‚’ã‚«ãƒ¡ãƒ©ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«è¨­å®š
        if (bounds) {
          // ãƒ¡ãƒ¼ãƒˆãƒ«å˜ä½ã§è¨­å®šï¼ˆmodel-viewerã®ä»•æ§˜ï¼‰
          modelViewer.cameraTarget = `${bounds.x}m ${bounds.y}m ${bounds.z}m`;
        } else {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: è‡ªå‹•ã‚»ãƒ³ã‚¿ãƒªãƒ³ã‚°
          modelViewer.cameraTarget = "auto auto auto";
        }
        
        // ç¾åœ¨ã®è§’åº¦ã‚’ç¶­æŒã—ãªãŒã‚‰è·é›¢ã®ã¿ã‚’èª¿æ•´
        const theta = currentOrbit.theta;
        const phi = currentOrbit.phi;
        
        // ãƒ¢ãƒ‡ãƒ«å…¨ä½“ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«è·é›¢ã‚’èª¿æ•´
        modelViewer.cameraOrbit = `${theta}rad ${phi}rad 105%`;
        
        // ã‚¹ãƒ ãƒ¼ã‚ºãªãƒˆãƒ©ãƒ³ã‚¸ã‚·ãƒ§ãƒ³
        modelViewer.interpolationDecay = 100;
        
        console.log("Model centered with target:", modelViewer.cameraTarget);
        console.log("Model centered with orbit:", modelViewer.cameraOrbit);
      }
      
      // ã‚»ãƒ³ã‚¿ãƒ¼ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
      centerButton.addEventListener("click", () => {
        centerModel();
      });

      // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†
      modelViewer.addEventListener("load", () => {
        console.log("Model loaded successfully");
        updateBackgroundColor();

        // è£é¢ã«è‰²ã‚’ã¤ã‘ã‚‹ - è¤‡æ•°ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’é †æ¬¡è©¦è¡Œ
        setTimeout(() => {
          addBackfaceColorSimple();
        }, 500);
      });

      modelViewer.addEventListener("error", (event) => {
        console.error("ğŸš¨ Model loading error detected:", event.detail);
        console.error("ğŸš¨ Current model src:", modelViewer.src);
        console.error("ğŸš¨ Error event object:", event);
        
        customProgressBar.style.display = "none";

        // ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
        let errorMsg = "Failed to load 3D model";
        if (event.detail) {
          if (event.detail.type === "loadfailure") {
            // sourceErrorã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã‚ˆã‚Šè©³ç´°ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ
            if (event.detail.sourceError) {
              const sourceError = event.detail.sourceError;
              console.error("ğŸš¨ Source error:", sourceError);
              
              // TypeError: Failed to fetchã¯CORSã¾ãŸã¯ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼
              if (sourceError.message && sourceError.message.includes("Failed to fetch")) {
                errorMsg = "Network error or CORS policy blocked the request";
                console.error("ğŸš¨ CORS/Network error detected");
              } else if (
                sourceError.message &&
                sourceError.message.includes("Invalid typed array length")
              ) {
                errorMsg = "Model file is too large for browser memory";
              } else if (
                sourceError.message &&
                sourceError.message.includes("texture")
              ) {
                errorMsg = "Failed to load model textures";
              } else if (
                sourceError.message &&
                sourceError.message.includes("scene")
              ) {
                errorMsg = "Model file is corrupted or incompatible format";
              } else {
                errorMsg = `Model loading failed: ${sourceError.message || "Unknown error"}`;
              }
            } else {
              // WebViewç’°å¢ƒã‹ã©ã†ã‹ã§ç•°ãªã‚‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
              if (detectWebView()) {
                errorMsg = "Failed to load 3D model in this browser environment";
              } else {
                errorMsg = "Failed to load 3D model";
              }
              console.error("ğŸš¨ Load failure detected without source error");
            }
          } else if (event.detail.sourceError) {
            const sourceError = event.detail.sourceError;
            console.error("ğŸš¨ Source error without loadfailure:", sourceError);
            errorMsg = `Model loading error: ${sourceError.message || "Unknown error"}`;
          }
        }

        console.error("ğŸš¨ Final error message:", errorMsg);
        console.error("ğŸš¨ Model URL:", modelViewer.src);
        showError(errorMsg, modelViewer.src);
      });

      // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆç›£è¦–ã‚’è¿½åŠ 
      let loadingTimeout;
      
      modelViewer.addEventListener("progress", (event) => {
        const progress = event.detail.totalProgress;
        console.log(`ğŸ“Š Loading progress: ${(progress * 100).toFixed(1)}%`);

        progressBarFill.style.width = `${progress * 100}%`;
        progressPercent.textContent = `${Math.round(progress * 100)}%`;

        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
        clearTimeout(loadingTimeout);
        
        // é€²è¡ŒãŒæ­¢ã¾ã£ãŸå ´åˆã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆï¼ˆ30ç§’ï¼‰
        loadingTimeout = setTimeout(() => {
          console.error("ğŸš¨ Loading timeout detected - no progress for 30 seconds");
          if (progress < 1.0) {
            console.error("ğŸš¨ Calling showError due to timeout");
            showError("Loading timed out - possible network or memory issue", modelViewer.src);
          }
        }, 30000);

        // 100%ã«ãªã£ãŸã‚‰å³åº§ã«éè¡¨ç¤º
        if (progress >= 1.0) {
          customProgressBar.style.display = "none";
          clearTimeout(loadingTimeout);
        } else {
          customProgressBar.style.display = "flex";
        }
      });


      // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¤ãƒ™ãƒ³ãƒˆ
      exposureSlider.addEventListener("input", (e) => {
        const value = parseFloat(e.target.value);
        modelViewer.exposure = value;
        exposureValue.textContent = Math.round(value * 100);
      });

      shadowSlider.addEventListener("input", (e) => {
        const value = parseFloat(e.target.value);
        modelViewer.shadowIntensity = value;
        shadowValue.textContent = Math.round(value * 100);
      });

      // èƒŒæ™¯è‰²å¤‰æ›´
      bgBlackBtn.addEventListener("click", () => {
        currentBackgroundColor = "black";
        updateBackgroundButtons();
        updateBackgroundColor();
      });

      bgWhiteBtn.addEventListener("click", () => {
        currentBackgroundColor = "white";
        updateBackgroundButtons();
        updateBackgroundColor();
      });

      function updateBackgroundButtons() {
        bgBlackBtn.classList.toggle(
          "active",
          currentBackgroundColor === "black"
        );
        bgWhiteBtn.classList.toggle(
          "active",
          currentBackgroundColor === "white"
        );
      }

      function updateBackgroundColor() {
        const bgColor =
          currentBackgroundColor === "black" ? "#000000" : "#ffffff";
        modelViewer.style.setProperty("--poster-color", bgColor);
        modelViewer.style.backgroundColor = bgColor;

        // Shadow rootã®canvasã«ã‚‚é©ç”¨
        setTimeout(() => {
          const shadowRoot = modelViewer.shadowRoot;
          if (shadowRoot) {
            const canvas = shadowRoot.querySelector("canvas");
            if (canvas) {
              canvas.style.backgroundColor = bgColor;
            }
          }
        }, 100);
      }

      // ãƒ—ãƒªã‚»ãƒƒãƒˆè¨­å®š
      function setPreset(exposure, shadow) {
        exposureSlider.value = exposure;
        shadowSlider.value = shadow;
        modelViewer.exposure = exposure;
        modelViewer.shadowIntensity = shadow;
        exposureValue.textContent = Math.round(exposure * 100);
        shadowValue.textContent = Math.round(shadow * 100);
      }

      // ã‚µãƒ³ãƒ—ãƒ«ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
      function loadSampleModel(url) {
        console.log("Loading model:", url);
        
        // URLã®æ¤œè¨¼
        if (!isValidModelUrl(url)) {
          showError("Invalid model URL or unsupported file format", url);
          return;
        }
        
        modelViewer.src = url;
        customProgressBar.style.display = "flex";
        clearError();
      }
      
      // ãƒ¢ãƒ‡ãƒ«URLã®æ¤œè¨¼
      function isValidModelUrl(url) {
        try {
          const urlObj = new URL(url);
          
          // ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®ãƒã‚§ãƒƒã‚¯
          if (!['http:', 'https:'].includes(urlObj.protocol)) {
            console.error("ğŸš¨ Invalid protocol. Only HTTP/HTTPS is supported");
            return false;
          }
          
          // æ‹¡å¼µå­ãƒã‚§ãƒƒã‚¯ã¯è¡Œã‚ãªã„
          // model-viewerãŒå†…éƒ¨ã§MIMEã‚¿ã‚¤ãƒ—ã‚„ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã‚’ç¢ºèªã™ã‚‹
          console.log("âœ… URL validation passed:", url);
          
          return true;
        } catch (e) {
          console.error("ğŸš¨ Invalid URL:", e);
          return false;
        }
      }

      // ãƒ¡ãƒ¢ãƒªãƒ»ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å®¹é‡ã‚’ãƒã‚§ãƒƒã‚¯
      function checkMemoryAndStorage() {
        const issues = [];
        const details = {};
        
        // åˆ©ç”¨å¯èƒ½ãƒ¡ãƒ¢ãƒªã®æ¨å®š
        if (navigator.deviceMemory) {
          details.deviceMemory = `${navigator.deviceMemory}GB`;
          if (navigator.deviceMemory < 4) {
            issues.push(`ãƒ‡ãƒã‚¤ã‚¹ãƒ¡ãƒ¢ãƒªãŒä¸è¶³ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ (${navigator.deviceMemory}GB)`);
          }
        }
        
        // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸å®¹é‡ãƒã‚§ãƒƒã‚¯
        try {
          const testKey = 'storage_test_' + Date.now();
          const testData = 'x'.repeat(1024 * 1024); // 1MBã®ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
          localStorage.setItem(testKey, testData);
          localStorage.removeItem(testKey);
          
          // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®ä½¿ç”¨çŠ¶æ³ã‚’æ¨å®š
          let localStorageSize = 0;
          for (let key in localStorage) {
            if (localStorage.hasOwnProperty(key)) {
              localStorageSize += localStorage[key].length + key.length;
            }
          }
          details.localStorageUsed = `${(localStorageSize / 1024).toFixed(1)}KB`;
        } catch (e) {
          if (e.name === 'QuotaExceededError') {
            issues.push('ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã®å®¹é‡ãŒä¸è¶³ã—ã¦ã„ã¾ã™');
            details.localStorageStatus = 'FULL';
          }
        }
        
        // ãƒ’ãƒ¼ãƒ—ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒã‚§ãƒƒã‚¯ï¼ˆChromeé™å®šï¼‰
        if (performance.memory) {
          const usedMB = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(1);
          const limitMB = (performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(1);
          const memoryRatio = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;
          
          details.jsHeapUsed = `${usedMB}MB / ${limitMB}MB (${(memoryRatio * 100).toFixed(0)}%)`;
          
          if (memoryRatio > 0.8) {
            issues.push(`ãƒ–ãƒ©ã‚¦ã‚¶ã®ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãŒé«˜ã™ãã¾ã™ (${(memoryRatio * 100).toFixed(0)}%ä½¿ç”¨ä¸­)`);
          }
        }
        
        // Storage APIï¼ˆä½¿ç”¨å¯èƒ½ãªå ´åˆï¼‰ã§ãƒ‡ã‚£ã‚¹ã‚¯å®¹é‡ã‚’ãƒã‚§ãƒƒã‚¯
        if (navigator.storage && navigator.storage.estimate) {
          navigator.storage.estimate().then(estimate => {
            const usedMB = (estimate.usage / 1024 / 1024).toFixed(1);
            const quotaMB = (estimate.quota / 1024 / 1024).toFixed(1);
            const usagePercent = ((estimate.usage / estimate.quota) * 100).toFixed(0);
            
            details.storageEstimate = `${usedMB}MB / ${quotaMB}MB (${usagePercent}%)`;
            console.log('Storage estimate:', details.storageEstimate);
          });
        }
        
        return { issues, details };
      }
      
      // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã¨ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢
      function clearStorageAndReload() {
        try {
          // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¯ãƒªã‚¢
          localStorage.clear();
          
          // ã‚»ãƒƒã‚·ãƒ§ãƒ³ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¯ãƒªã‚¢
          sessionStorage.clear();
          
          // IndexedDBã‚‚ã‚¯ãƒªã‚¢ï¼ˆå¯èƒ½ã§ã‚ã‚Œã°ï¼‰
          if ('indexedDB' in window) {
            indexedDB.databases().then(databases => {
              databases.forEach(db => {
                indexedDB.deleteDatabase(db.name);
              });
            }).catch(() => {
              console.log('IndexedDB clear failed (may not be supported)');
            });
          }
          
          // ã‚­ãƒ£ãƒƒã‚·ãƒ¥APIã‚¯ãƒªã‚¢ï¼ˆService Workerä½¿ç”¨æ™‚ï¼‰
          if ('caches' in window) {
            caches.keys().then(names => {
              names.forEach(name => {
                caches.delete(name);
              });
            });
          }
          
          console.log('Storage cleared successfully');
          
          // 2ç§’å¾Œã«ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿
          setTimeout(() => {
            window.location.reload(true);
          }, 2000);
          
          return true;
        } catch (error) {
          console.error('Storage clear failed:', error);
          return false;
        }
      }

      // ==========================================
      // ã‚¨ãƒ©ãƒ¼å‡¦ç†ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
      // ==========================================
      
      // ç’°å¢ƒæ¤œå‡ºã‚¯ãƒ©ã‚¹
      class EnvironmentDetector {
        constructor() {
          this.userAgent = navigator.userAgent;
          this.isMetaMask = this.detectMetaMask();
          this.isWebView = this.detectWebView();
          this.platform = this.detectPlatform();
        }
        
        detectMetaMask() {
          return (window.ethereum && window.ethereum.isMetaMask) || /MetaMask/i.test(this.userAgent);
        }
        
        detectWebView() {
          if (this.isMetaMask) return true;
          
          const webViewPatterns = [
            /wv/i, /WebView/i, /FBAN|FBAV/i, /Line/i, 
            /Instagram/i, /Twitter/i
          ];
          
          return webViewPatterns.some(pattern => pattern.test(this.userAgent));
        }
        
        detectPlatform() {
          const isAndroid = /Android/i.test(this.userAgent);
          const isIOS = /iPhone|iPad|iPod/i.test(this.userAgent);
          const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(this.userAgent);
          
          return { isAndroid, isIOS, isMobile };
        }
      }
      
      // ã‚¨ãƒ©ãƒ¼åˆ†æã‚¯ãƒ©ã‚¹
      class ErrorAnalyzer {
        constructor(environment) {
          this.environment = environment;
        }
        
        analyze(message, modelUrl) {
          const errorType = {
            type: 'unknown',
            category: 'general',
            showMemoryInfo: false,
            solutions: []
          };
          
          const lowerMessage = message.toLowerCase();
          
          // CORSã‚¨ãƒ©ãƒ¼
          if (this.isCorsError(lowerMessage)) {
            errorType.type = 'cors';
            errorType.category = 'network';
            errorType.solutions = [
              'ã“ã®ãƒ¢ãƒ‡ãƒ«ã®ãƒ›ã‚¹ãƒˆã‚µãƒ¼ãƒãƒ¼ãŒCORSè¨­å®šã‚’è¨±å¯ã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™',
              'ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒ“ã‚¹ã‚’çµŒç”±ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã‹ã€ãƒ¢ãƒ‡ãƒ«ã‚’åˆ¥ã®ãƒ›ã‚¹ãƒˆã«é…ç½®ã—ã¦ãã ã•ã„'
            ];
          }
          // ãƒ¡ãƒ¢ãƒªã‚¨ãƒ©ãƒ¼
          else if (this.isMemoryError(lowerMessage)) {
            errorType.type = 'memory';
            errorType.category = 'resource';
            errorType.showMemoryInfo = true;
            errorType.solutions = [
              'ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãŒå¤§ãã™ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™',
              'ä»–ã®ã‚¿ãƒ–ã‚’é–‰ã˜ã¦ãƒ¡ãƒ¢ãƒªã‚’è§£æ”¾ã—ã¦ãã ã•ã„',
              'ã‚ˆã‚Šå°ã•ã„ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„'
            ];
          }
          // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
          else if (this.isTimeoutError(lowerMessage)) {
            errorType.type = 'timeout';
            errorType.category = 'network';
            errorType.solutions = [
              'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šãŒé…ã„ã‹ä¸å®‰å®šãªå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™',
              'ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™'
            ];
          }
          // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼
          else if (this.isFormatError(lowerMessage)) {
            errorType.type = 'format';
            errorType.category = 'file';
            errorType.solutions = this.getFormatErrorSolutions();
          }
          // ãã®ä»–ã®ã‚¨ãƒ©ãƒ¼
          else {
            errorType.solutions = this.getGenericSolutions();
          }
          
          return errorType;
        }
        
        isCorsError(message) {
          return message.includes('cors') || message.includes('cross-origin') || 
                 message.includes('network error') || message.includes('failed to fetch');
        }
        
        isMemoryError(message) {
          return message.includes('memory') || message.includes('typed array length') ||
                 message.includes('out of memory');
        }
        
        isTimeoutError(message) {
          return message.includes('timeout') || message.includes('timed out');
        }
        
        isFormatError(message) {
          return message.includes('corrupted') || message.includes('incompatible') ||
                 message.includes('invalid');
        }
        
        getFormatErrorSolutions() {
          if (this.environment.isWebView) {
            return [
              'ã“ã®ã‚¢ãƒ—ãƒªå†…ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ä¸€éƒ¨ã®3Dãƒ¢ãƒ‡ãƒ«ãŒè¡¨ç¤ºã§ããªã„å ´åˆãŒã‚ã‚Šã¾ã™',
              'æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ï¼ˆChromeã€Safariç­‰ï¼‰ã§é–‹ãã“ã¨ã§æ­£å¸¸ã«è¡¨ç¤ºã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™'
            ];
          } else {
            return [
              'ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¾ãŸã¯ãƒ‡ãƒã‚¤ã‚¹ã§ã¯ã€ã“ã®ãƒ¢ãƒ‡ãƒ«ã®è¡¨ç¤ºã«å¯¾å¿œã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™',
              'åˆ¥ã®ãƒ–ãƒ©ã‚¦ã‚¶ã‚„ãƒ‡ãƒã‚¤ã‚¹ã§è©¦ã—ã¦ã¿ã¦ãã ã•ã„',
              'ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãŒç‰¹æ®Šãªå½¢å¼ã‚„æ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™'
            ];
          }
        }
        
        getGenericSolutions() {
          if (this.environment.isWebView) {
            return [
              'ã‚¢ãƒ—ãƒªå†…ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆ¶é™ã«ã‚ˆã‚Šã€3Dãƒ¢ãƒ‡ãƒ«ã‚’è¡¨ç¤ºã§ãã¾ã›ã‚“',
              'æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ï¼ˆChromeã€Safariç­‰ï¼‰ã§é–‹ã„ã¦ãã ã•ã„'
            ];
          } else {
            return [
              'ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ',
              'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„',
              'ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†åº¦ãŠè©¦ã—ãã ã•ã„'
            ];
          }
        }
      }
      
      // ã‚¨ãƒ©ãƒ¼UIç”Ÿæˆã‚¯ãƒ©ã‚¹
      class ErrorUIGenerator {
        constructor(environment) {
          this.environment = environment;
        }
        
        generateLoadingUI(message) {
          return `
            <div class="error-display">
              <div class="error-icon">âš ï¸</div>
              <div class="error-text">
                <p class="error-title">3D Model Loading Error</p>
                <p class="error-message">${message}</p>
                <div style="margin-top: 20px; text-align: center;">
                  <div class="error-spinner"></div>
                  <p style="font-size: 14px; color: #666; margin-top: 15px;">
                    åŸå› ã‚’èª¿æŸ»ä¸­...
                  </p>
                </div>
              </div>
            </div>
          `;
        }
        
        generateDetailedUI(message, errorAnalysis, memoryInfo, modelUrl) {
          const { memoryIssues, memoryDetails } = memoryInfo;
          
          return `
            <div class="error-display">
              <div class="error-icon">âš ï¸</div>
              <div class="error-text">
                <p class="error-title">3D Model Loading Error</p>
                <p class="error-message">${message}</p>
                ${this.generateHelpMessage()}
                ${this.generateSolutions(errorAnalysis)}
                ${this.generateSystemInfo(errorAnalysis, memoryIssues, memoryDetails)}
                ${this.generateStorageActions(memoryIssues)}
                ${this.generateButtons(errorAnalysis, modelUrl)}
                ${this.generateAdditionalButtons(memoryIssues)}
              </div>
            </div>
          `;
        }
        
        generateHelpMessage() {
          if (!this.environment.isWebView) return '';
          
          if (this.environment.isMetaMask) {
            return `
              <p class="error-message" style="font-size: 12px; color: #888; margin-top: 10px;">MetaMaskãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯3Dè¡¨ç¤ºã«åˆ¶é™ãŒã‚ã‚Šã¾ã™ã€‚Chrome/Safariãªã©ã®æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã„ã¦ãã ã•ã„ã€‚</p>
              <div class="metamask-hint">
                â‹¯ ã‚ˆã‚Šã€Œãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ãã€ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’ãŠè©¦ã—ãã ã•ã„
              </div>
            `;
          } else {
            return '<p class="error-message" style="font-size: 12px; color: #888; margin-top: 10px;">ã“ã®ã‚¢ãƒ—ãƒªå†…ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯3Dè¡¨ç¤ºã«åˆ¶é™ãŒã‚ã‚Šã¾ã™ã€‚æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ï¼ˆChromeã€Safariç­‰ï¼‰ã§é–‹ã„ã¦ãã ã•ã„ã€‚</p>';
          }
        }
        
        generateSolutions(errorAnalysis) {
          if (errorAnalysis.solutions.length === 0) return '';
          
          return `
            <div style="margin: 15px 0; padding: 10px; background: rgba(23, 162, 184, 0.1); border-left: 3px solid #17a2b8; border-radius: 4px;">
              <p style="font-size: 12px; color: #0c5460; margin: 0 0 8px 0;"><strong>è€ƒãˆã‚‰ã‚Œã‚‹åŸå› ã¨å¯¾å‡¦æ³•:</strong></p>
              ${errorAnalysis.solutions.map(solution => `<p style="font-size: 11px; color: #0c5460; margin: 2px 0;">â€¢ ${solution}</p>`).join('')}
            </div>
          `;
        }
        
        generateSystemInfo(errorAnalysis, memoryIssues, memoryDetails) {
          if (!errorAnalysis.showMemoryInfo && memoryIssues.length === 0) return '';
          
          return `
            <div style="margin: 15px 0; padding: 10px; background: rgba(108, 117, 125, 0.1); border-left: 3px solid #6c757d; border-radius: 4px;">
              <p style="font-size: 12px; color: #495057; margin: 0 0 8px 0;"><strong>ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±:</strong></p>
              ${memoryDetails.deviceMemory ? `<p style="font-size: 11px; color: #495057; margin: 2px 0;">â€¢ ãƒ‡ãƒã‚¤ã‚¹ãƒ¡ãƒ¢ãƒª: ${memoryDetails.deviceMemory}</p>` : ''}
              ${memoryDetails.jsHeapUsed ? `<p style="font-size: 11px; color: #495057; margin: 2px 0;">â€¢ JSãƒ’ãƒ¼ãƒ—ä½¿ç”¨é‡: ${memoryDetails.jsHeapUsed}</p>` : ''}
              ${memoryDetails.localStorageUsed ? `<p style="font-size: 11px; color: #495057; margin: 2px 0;">â€¢ LocalStorageä½¿ç”¨é‡: ${memoryDetails.localStorageUsed}</p>` : ''}
              ${memoryDetails.localStorageStatus === 'FULL' ? `<p style="font-size: 11px; color: #dc3545; margin: 2px 0;">â€¢ LocalStorage: å®¹é‡ä¸Šé™ã«é”ã—ã¦ã„ã¾ã™</p>` : ''}
            </div>
          `;
        }
        
        generateStorageActions(memoryIssues) {
          if (memoryIssues.length === 0) return '';
          
          return `
            <div style="margin: 15px 0; padding: 10px; background: rgba(255, 193, 7, 0.1); border-left: 3px solid #ffc107; border-radius: 4px;">
              <p style="font-size: 12px; color: #856404; margin: 0 0 8px 0;"><strong>æ¤œå‡ºã•ã‚ŒãŸå•é¡Œ:</strong></p>
              ${memoryIssues.map(issue => `<p style="font-size: 11px; color: #856404; margin: 2px 0;">â€¢ ${issue}</p>`).join('')}
            </div>
            <button onclick="clearStorageAndReload()" class="viewer-link" style="background: #ffc107; color: #000; margin-bottom: 8px;">
              ğŸ—‘ï¸ ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢ã—ã¦å†èª­ã¿è¾¼ã¿
            </button>
          `;
        }
        
        generateButtons(errorAnalysis, modelUrl) {
          if (this.environment.isWebView) {
            const buttonText = this.environment.isMetaMask 
              ? 'ğŸ“± å¤–éƒ¨ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ãï¼ˆChrome/Safariï¼‰'
              : 'ğŸ“‹ URLã‚’ã‚³ãƒ”ãƒ¼ã—ã¦æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã';
              
            return `
              <button onclick="openInDefaultBrowser('${modelUrl}')" class="viewer-link">
                ${buttonText}
              </button>
            `;
          } else {
            if (errorAnalysis.type === 'cors' || errorAnalysis.type === 'network') {
              return `
                <button onclick="window.location.reload()" class="viewer-link">
                  ğŸ”„ å†è©¦è¡Œ
                </button>
                <button onclick="window.location.href=window.location.pathname" class="viewer-link" style="background: #6c757d; margin-left: 5px;">
                  ğŸ  ãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹
                </button>
              `;
            } else {
              return `
                <button onclick="window.location.reload()" class="viewer-link">
                  ğŸ”„ ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿
                </button>
              `;
            }
          }
        }
        
        generateAdditionalButtons(memoryIssues) {
          if (!this.environment.isWebView && memoryIssues.length > 0) {
            return `<button onclick="clearStorageAndReload()" class="viewer-link" style="background: #6c757d; margin-top: 5px;">
              ğŸ  ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¯ãƒªã‚¢å¾Œãƒ›ãƒ¼ãƒ ã«æˆ»ã‚‹
            </button>`;
          }
          return '';
        }
      }
      
      // ã‚¨ãƒ©ãƒ¼ã®ç¨®é¡ã‚’åˆ¤åˆ¥ï¼ˆäº’æ›æ€§ã®ãŸã‚æ®‹ã™ - å‰Šé™¤äºˆå®šï¼‰
      function analyzeErrorType(message, modelUrl) {
        const environment = new EnvironmentDetector();
        const analyzer = new ErrorAnalyzer(environment);
        return analyzer.analyze(message, modelUrl);
      }
      
      // å¤ã„analyzeErrorTypeå®Ÿè£…ï¼ˆå‚è€ƒç”¨ã«ã‚³ãƒ¡ãƒ³ãƒˆåŒ–ï¼‰
      /*
      function analyzeErrorType_OLD(message, modelUrl) {
        const errorType = {
          type: 'unknown',
          category: 'general',
          showMemoryInfo: false,
          solutions: []
        };
        
        const lowerMessage = message.toLowerCase();
        const isInWebView = detectWebView();
        
        // CORSã‚¨ãƒ©ãƒ¼
        if (lowerMessage.includes('cors') || lowerMessage.includes('cross-origin') || 
            lowerMessage.includes('network error') || lowerMessage.includes('failed to fetch')) {
          errorType.type = 'cors';
          errorType.category = 'network';
          errorType.solutions = [
            'ã“ã®ãƒ¢ãƒ‡ãƒ«ã®ãƒ›ã‚¹ãƒˆã‚µãƒ¼ãƒãƒ¼ãŒCORSè¨­å®šã‚’è¨±å¯ã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™',
            'ãƒ—ãƒ­ã‚­ã‚·ã‚µãƒ¼ãƒ“ã‚¹ã‚’çµŒç”±ã—ã¦ã‚¢ã‚¯ã‚»ã‚¹ã™ã‚‹ã‹ã€ãƒ¢ãƒ‡ãƒ«ã‚’åˆ¥ã®ãƒ›ã‚¹ãƒˆã«é…ç½®ã—ã¦ãã ã•ã„'
          ];
        }
        // ãƒ¡ãƒ¢ãƒªã‚¨ãƒ©ãƒ¼
        else if (lowerMessage.includes('memory') || lowerMessage.includes('typed array length') ||
                 lowerMessage.includes('out of memory')) {
          errorType.type = 'memory';
          errorType.category = 'resource';
          errorType.showMemoryInfo = true;
          errorType.solutions = [
            'ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãŒå¤§ãã™ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™',
            'ä»–ã®ã‚¿ãƒ–ã‚’é–‰ã˜ã¦ãƒ¡ãƒ¢ãƒªã‚’è§£æ”¾ã—ã¦ãã ã•ã„',
            'ã‚ˆã‚Šå°ã•ã„ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„'
          ];
        }
        // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
        else if (lowerMessage.includes('timeout') || lowerMessage.includes('timed out')) {
          errorType.type = 'timeout';
          errorType.category = 'network';
          errorType.solutions = [
            'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šãŒé…ã„ã‹ä¸å®‰å®šãªå¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™',
            'ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºãŒå¤§ãã™ãã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™'
          ];
        }
        // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‚¨ãƒ©ãƒ¼ï¼ˆWebViewç’°å¢ƒã‚’è€ƒæ…®ï¼‰
        else if (lowerMessage.includes('corrupted') || lowerMessage.includes('incompatible') ||
                 lowerMessage.includes('invalid')) {
          errorType.type = 'format';
          errorType.category = 'file';
          
          // WebViewç’°å¢ƒã®å ´åˆã¯åˆ¥ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
          if (isInWebView) {
            errorType.solutions = [
              'ã“ã®ã‚¢ãƒ—ãƒªå†…ãƒ–ãƒ©ã‚¦ã‚¶ã§ã¯ä¸€éƒ¨ã®3Dãƒ¢ãƒ‡ãƒ«ãŒè¡¨ç¤ºã§ããªã„å ´åˆãŒã‚ã‚Šã¾ã™',
              'æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ï¼ˆChromeã€Safariç­‰ï¼‰ã§é–‹ãã“ã¨ã§æ­£å¸¸ã«è¡¨ç¤ºã•ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™'
            ];
          } else {
            errorType.solutions = [
              'ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¾ãŸã¯ãƒ‡ãƒã‚¤ã‚¹ã§ã¯ã€ã“ã®ãƒ¢ãƒ‡ãƒ«ã®è¡¨ç¤ºã«å¯¾å¿œã—ã¦ã„ãªã„å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™',
              'åˆ¥ã®ãƒ–ãƒ©ã‚¦ã‚¶ã‚„ãƒ‡ãƒã‚¤ã‚¹ã§è©¦ã—ã¦ã¿ã¦ãã ã•ã„',
              'ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ãŒç‰¹æ®Šãªå½¢å¼ã‚„æ©Ÿèƒ½ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™'
            ];
          }
        }
        // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¨ãƒ©ãƒ¼
        else if (lowerMessage.includes('texture')) {
          errorType.type = 'texture';
          errorType.category = 'file';
          errorType.solutions = [
            'ãƒ¢ãƒ‡ãƒ«ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¦‹ã¤ã‹ã‚‰ãªã„ã‹èª­ã¿è¾¼ã‚ã¾ã›ã‚“',
            'ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ãŒãƒ¢ãƒ‡ãƒ«ã¨åŒã˜å ´æ‰€ã«ã‚ã‚‹ã“ã¨ã‚’ç¢ºèªã—ã¦ãã ã•ã„'
          ];
        }
        // WebGLã‚¨ãƒ©ãƒ¼
        else if (lowerMessage.includes('webgl') || lowerMessage.includes('context')) {
          errorType.type = 'webgl';
          errorType.category = 'browser';
          errorType.solutions = [
            'ãƒ–ãƒ©ã‚¦ã‚¶ã®WebGLæ©Ÿèƒ½ãŒç„¡åŠ¹ã«ãªã£ã¦ã„ã‚‹ã‹ã€ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“',
            'ãƒ–ãƒ©ã‚¦ã‚¶ã®è¨­å®šã§ãƒãƒ¼ãƒ‰ã‚¦ã‚§ã‚¢ã‚¢ã‚¯ã‚»ãƒ©ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã‚’æœ‰åŠ¹ã«ã—ã¦ãã ã•ã„'
          ];
        }
        // ä¸€èˆ¬çš„ãªãƒ­ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ï¼ˆWebViewç’°å¢ƒã‚’è€ƒæ…®ï¼‰
        else if (lowerMessage.includes('failed to load') || lowerMessage.includes('loading failed')) {
          errorType.type = 'load';
          errorType.category = 'general';
          
          if (isInWebView) {
            errorType.solutions = [
              'ã‚¢ãƒ—ãƒªå†…ãƒ–ãƒ©ã‚¦ã‚¶ã®åˆ¶é™ã«ã‚ˆã‚Šã€3Dãƒ¢ãƒ‡ãƒ«ã‚’è¡¨ç¤ºã§ãã¾ã›ã‚“',
              'æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ï¼ˆChromeã€Safariç­‰ï¼‰ã§é–‹ã„ã¦ãã ã•ã„'
            ];
          } else {
            errorType.solutions = [
              'ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ',
              'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„',
              'ã—ã°ã‚‰ãå¾…ã£ã¦ã‹ã‚‰å†åº¦ãŠè©¦ã—ãã ã•ã„'
            ];
          }
        }
        
        return errorType;
      }
      */

      // ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºï¼ˆã‚·ãƒ³ãƒ—ãƒ«åŒ–ï¼‰
      function showError(message, modelUrl) {
        const container = document.querySelector(".container");
        const environment = new EnvironmentDetector();
        const uiGenerator = new ErrorUIGenerator(environment);
        
        // ã¾ãšåŸå› èª¿æŸ»ä¸­ã®è¡¨ç¤ºã‚’å‡ºã™
        container.innerHTML = uiGenerator.generateLoadingUI(message);
        
        // å°‘ã—é…å»¶ã‚’å…¥ã‚Œã¦åŸå› èª¿æŸ»ã‚’å®Ÿè¡Œ
        setTimeout(() => {
          // ç’°å¢ƒã¨ã‚¨ãƒ©ãƒ¼ã®åˆ†æ
          const errorAnalyzer = new ErrorAnalyzer(environment);
          const errorAnalysis = errorAnalyzer.analyze(message, modelUrl);
          
          // ãƒ¡ãƒ¢ãƒªæƒ…å ±ã®å–å¾—
          const memoryCheck = checkMemoryAndStorage();
          const memoryInfo = {
            memoryIssues: memoryCheck.issues,
            memoryDetails: memoryCheck.details
          };
          
          // è©³ç´°UIã®ç”Ÿæˆã¨è¡¨ç¤º
          container.innerHTML = uiGenerator.generateDetailedUI(
            message,
            errorAnalysis,
            memoryInfo,
            modelUrl
          );
        }, 1500); // 1.5ç§’å¾Œã«è©³ç´°æƒ…å ±ã‚’è¡¨ç¤º
      }

      function clearError() {
        // ã‚¨ãƒ©ãƒ¼è¡¨ç¤ºã‚’ã‚¯ãƒªã‚¢ï¼ˆå¿…è¦ã«å¿œã˜ã¦å®Ÿè£…ï¼‰
      }

      // WebViewç’°å¢ƒã®æ¤œå‡ºï¼ˆäº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
      function detectWebView() {
        const detector = new EnvironmentDetector();
        return detector.isWebView;
      }
      
      // MetaMaskãƒ–ãƒ©ã‚¦ã‚¶ã‹ã©ã†ã‹ã‚’åˆ¤å®šï¼ˆäº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
      function isMetaMaskBrowser() {
        const detector = new EnvironmentDetector();
        return detector.isMetaMask;
      }

      // æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ã§URLã‚’é–‹ã
      function openInDefaultBrowser(modelUrl) {
        const currentUrl = window.location.href;
        const baseUrl = currentUrl.split('?')[0];
        const fullUrl = `${baseUrl}?src=${encodeURIComponent(modelUrl)}`;
        
        console.log('Attempting to open in default browser:', fullUrl);
        
        // MetaMaskãƒ–ãƒ©ã‚¦ã‚¶ã®å ´åˆã®ç‰¹åˆ¥å‡¦ç†
        if (isMetaMaskBrowser()) {
          // ãƒ¢ãƒã‚¤ãƒ«OSã®åˆ¤å®š
          const isAndroid = /Android/i.test(navigator.userAgent);
          const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
          
          if (isAndroid) {
            // Androidã®å ´åˆï¼šã¾ãšã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã‚’è©¦è¡Œ
            copyToClipboard(fullUrl).then((copySuccess) => {
              // Chromeèµ·å‹•ã‚’è©¦è¡Œ
              const intentUrl = `intent://${fullUrl.replace(/^https?:\/\//, '')}#Intent;scheme=https;package=com.android.chrome;end`;
              window.location.href = intentUrl;
              
              // 1.5ç§’å¾Œã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
              setTimeout(() => {
                if (copySuccess) {
                  alert(`URLã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚\n\nè‡ªå‹•ã§Chrome/æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ãŒé–‹ã‹ãªã„å ´åˆã¯ã€æ‰‹å‹•ã«ã¦ãƒ–ãƒ©ã‚¦ã‚¶ã®URLæ¬„ã«ãƒšãƒ¼ã‚¹ãƒˆã—ã¦ãã ã•ã„ã€‚\n\nã‚³ãƒ”ãƒ¼æ¸ˆã¿ã®URL:\n${fullUrl}`);
                } else {
                  alert(`URLã®ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n\nä»¥ä¸‹ã®URLã‚’æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã„ã¦ãã ã•ã„ï¼š\n${fullUrl}`);
                }
              }, 1500);
            });
          } else if (isIOS) {
            // iOSã®å ´åˆï¼šã¾ãšã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã‚’è©¦è¡Œ
            copyToClipboard(fullUrl).then((copySuccess) => {
              // Chromeèµ·å‹•ã‚’è©¦è¡Œ
              const chromeUrl = `googlechrome-x-callback://x-callback-url/open/?url=${encodeURIComponent(fullUrl)}`;
              window.location.href = chromeUrl;
              
              // 1.5ç§’å¾Œã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†
              setTimeout(() => {
                if (copySuccess) {
                  alert(`URLã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚\n\nè‡ªå‹•ã§Chrome/SafariãŒé–‹ã‹ãªã„å ´åˆã€æ‰‹å‹•ã«ã¦ãƒ–ãƒ©ã‚¦ã‚¶ã®URLæ¬„ã«ãƒšãƒ¼ã‚¹ãƒˆã—ã¦ãã ã•ã„ã€‚\n\nã‚³ãƒ”ãƒ¼æ¸ˆã¿ã®URL:\n${fullUrl}`);
                } else {
                  alert(`URLã®ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n\nä»¥ä¸‹ã®URLã‚’æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã„ã¦ãã ã•ã„ï¼š\n${fullUrl}`);
                }
              }, 1500);
            });
          } else {
            // ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—MetaMask
            copyToClipboard(fullUrl).then((copySuccess) => {
              if (copySuccess) {
                alert(`URLã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸã€‚\næ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ã§è²¼ã‚Šä»˜ã‘ã¦é–‹ã„ã¦ãã ã•ã„ã€‚\n\nã‚³ãƒ”ãƒ¼æ¸ˆã¿ã®URL:\n${fullUrl}`);
              } else {
                const userChoice = confirm(
                  'URLã®ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n\n' +
                  'ä»¥ä¸‹ã®æ–¹æ³•ã§å¯¾å‡¦ã§ãã¾ã™ï¼š\n' +
                  'â€¢ OK: URLã‚’è¡¨ç¤ºã—ã¦ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚³ãƒ”ãƒ¼\n' +
                  'â€¢ ã‚­ãƒ£ãƒ³ã‚»ãƒ«: å‰ã®ãƒšãƒ¼ã‚¸ã«æˆ»ã‚‹'
                );
                
                if (userChoice) {
                  prompt('ä»¥ä¸‹ã®URLã‚’æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„:', fullUrl);
                } else {
                  history.back();
                }
              }
            });
          }
          return;
        }
        
        // ãƒ¢ãƒã‚¤ãƒ«ç’°å¢ƒã®åˆ¤å®š
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        const isAndroid = /Android/i.test(navigator.userAgent);
        const isIOS = /iPhone|iPad|iPod/i.test(navigator.userAgent);
        
        // 1. Androidã®å ´åˆã€ã‚¤ãƒ³ãƒ†ãƒ³ãƒˆURLã‚’è©¦è¡Œ
        if (isAndroid && !isMetaMaskBrowser()) {
          const intentUrl = `intent://${fullUrl.replace(/^https?:\/\//, '')}#Intent;action=android.intent.action.VIEW;scheme=https;end`;
          window.location.href = intentUrl;
          
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: 3ç§’å¾Œã«ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã‚³ãƒ”ãƒ¼
          setTimeout(() => {
            copyToClipboardAndNotify(fullUrl);
          }, 3000);
          return;
        }
        
        // 2. iOSã®å ´åˆã€window.openã‚’è©¦è¡Œ
        if (isIOS && !isMetaMaskBrowser()) {
          const newWindow = window.open(fullUrl, '_blank');
          if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
            // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸå ´åˆ
            copyToClipboardAndNotify(fullUrl);
          }
          return;
        }
        
        // 3. ãƒ‡ã‚¹ã‚¯ãƒˆãƒƒãƒ—ã¾ãŸã¯ãã®ä»–ã®ç’°å¢ƒ
        try {
          // æ–°ã—ã„ã‚¿ãƒ–ã§é–‹ã
          const newWindow = window.open(fullUrl, '_blank');
          if (!newWindow || newWindow.closed || typeof newWindow.closed == 'undefined') {
            // ãƒãƒƒãƒ—ã‚¢ãƒƒãƒ—ãŒãƒ–ãƒ­ãƒƒã‚¯ã•ã‚ŒãŸå ´åˆ
            copyToClipboardAndNotify(fullUrl);
          }
        } catch (e) {
          // ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
          copyToClipboardAndNotify(fullUrl);
        }
      }
      
      // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ï¼ˆPromiseç‰ˆ - æˆåŠŸ/å¤±æ•—ã‚’è¿”ã™ï¼‰
      function copyToClipboard(url) {
        return new Promise((resolve) => {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            navigator.clipboard.writeText(url)
              .then(() => {
                console.log('Copied using Clipboard API');
                resolve(true);
              })
              .catch(() => {
                console.log('Clipboard API failed, trying fallback');
                resolve(fallbackCopyToClipboard(url));
              });
          } else {
            resolve(fallbackCopyToClipboard(url));
          }
        });
      }
      
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚³ãƒ”ãƒ¼ï¼ˆæˆåŠŸ/å¤±æ•—ã‚’è¿”ã™ï¼‰
      function fallbackCopyToClipboard(url) {
        try {
          const textArea = document.createElement('textarea');
          textArea.value = url;
          textArea.style.position = 'fixed';
          textArea.style.left = '-999999px';
          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();
          
          const successful = document.execCommand('copy');
          document.body.removeChild(textArea);
          
          if (successful) {
            console.log('Copied using execCommand');
            return true;
          } else {
            console.log('execCommand failed');
            return false;
          }
        } catch (error) {
          console.log('execCommand error:', error);
          return false;
        }
      }

      // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥ï¼ˆãƒ¬ã‚¬ã‚·ãƒ¼é–¢æ•°ï¼‰
      function copyToClipboardAndNotify(url) {
        console.log('Copying to clipboard:', url);
        
        copyToClipboard(url).then((success) => {
          if (success) {
            alert(`URLã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼\næ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ï¼ˆChromeã€Safariç­‰ï¼‰ã§è²¼ã‚Šä»˜ã‘ã¦é–‹ã„ã¦ãã ã•ã„ã€‚\n\nã‚³ãƒ”ãƒ¼ã•ã‚ŒãŸURL:\n${url}`);
          } else {
            const userChoice = confirm(
              'è‡ªå‹•ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n\n' +
              'ä»¥ä¸‹ã®æ–¹æ³•ã§å¯¾å‡¦ã§ãã¾ã™ï¼š\n' +
              'â€¢ OK: URLã‚’è¡¨ç¤ºã—ã¦ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚³ãƒ”ãƒ¼\n' +
              'â€¢ ã‚­ãƒ£ãƒ³ã‚»ãƒ«: å‰ã®ãƒšãƒ¼ã‚¸ã«æˆ»ã‚‹'
            );
            
            if (userChoice) {
              prompt('ä»¥ä¸‹ã®URLã‚’æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„:', url);
            } else {
              history.back();
            }
          }
        });
      }

      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ–¹æ³•ã§ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
      function fallbackCopyToClipboard(url) {
        try {
          // æ–¹æ³•1: document.execCommandï¼ˆå¤ã„ãƒ–ãƒ©ã‚¦ã‚¶å¯¾å¿œï¼‰
          const textArea = document.createElement('textarea');
          textArea.value = url;
          textArea.style.position = 'fixed';
          textArea.style.left = '-999999px';
          textArea.style.top = '-999999px';
          document.body.appendChild(textArea);
          textArea.select();
          textArea.setSelectionRange(0, 99999);
          
          const successful = document.execCommand('copy');
          document.body.removeChild(textArea);
          
          if (successful) {
            console.log('Copied using execCommand');
            showCopySuccessAlert(url);
          } else {
            console.log('execCommand failed, showing prompt');
            showManualCopyPrompt(url);
          }
        } catch (error) {
          console.log('execCommand error:', error);
          showManualCopyPrompt(url);
        }
      }

      // ã‚³ãƒ”ãƒ¼æˆåŠŸæ™‚ã®ã‚¢ãƒ©ãƒ¼ãƒˆè¡¨ç¤º
      function showCopySuccessAlert(url) {
        alert(`URLã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼\næ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ï¼ˆChromeã€Safariç­‰ï¼‰ã§è²¼ã‚Šä»˜ã‘ã¦é–‹ã„ã¦ãã ã•ã„ã€‚\n\nã‚³ãƒ”ãƒ¼ã•ã‚ŒãŸURL:\n${url}`);
      }

      // æ‰‹å‹•ã‚³ãƒ”ãƒ¼ç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆè¡¨ç¤ºï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—é˜²æ­¢ï¼‰
      function showManualCopyPrompt(url) {
        const userChoice = confirm(
          'è‡ªå‹•ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚\n\n' +
          'ä»¥ä¸‹ã®æ–¹æ³•ã§å¯¾å‡¦ã§ãã¾ã™ï¼š\n' +
          'â€¢ OK: URLã‚’è¡¨ç¤ºã—ã¦ãƒãƒ‹ãƒ¥ã‚¢ãƒ«ã‚³ãƒ”ãƒ¼\n' +
          'â€¢ ã‚­ãƒ£ãƒ³ã‚»ãƒ«: ãã®ã¾ã¾çµ‚äº†\n\n' +
          'URL: ' + url
        );
        
        if (userChoice) {
          // URLã‚’è¡¨ç¤ºã™ã‚‹ã ã‘ã§ã€å†è©¦è¡Œã¯ã—ãªã„
          alert(
            'URLã‚’ã‚³ãƒ”ãƒ¼ã—ã¦æ¨™æº–ãƒ–ãƒ©ã‚¦ã‚¶ã§é–‹ã„ã¦ãã ã•ã„ï¼š\n\n' + url + 
            '\n\nâ€»ã“ã®URLã‚’é¸æŠã—ã¦ã‚³ãƒ”ãƒ¼ï¼ˆCtrl+C / Cmd+Cï¼‰ã—ã¦ãã ã•ã„'
          );
        }
      }

      // ã‚·ãƒ³ãƒ—ãƒ«ãªè£é¢ã‚°ãƒ¬ãƒ¼ç€è‰²æ©Ÿèƒ½
      function addBackfaceColorSimple() {
        console.log("ğŸ¯ Starting backface gray coloring...");

        // ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿å®Œäº†ã¾ã§å°‘ã—å¾…ã¤
        setTimeout(() => {
          console.log("Checking model availability...");
          console.log("modelViewer.model:", modelViewer.model);
          console.log("modelViewer properties:", Object.keys(modelViewer));
          
          // è¤‡æ•°ã®æ–¹æ³•ã§ãƒ¢ãƒ‡ãƒ«ã«ã‚¢ã‚¯ã‚»ã‚¹
          let model = null;
          
          if (modelViewer.model) {
            model = modelViewer.model;
            console.log("âœ“ Found model via modelViewer.model");
          } else {
            // model-viewerã®å†…éƒ¨ã‚’æ¢ç´¢
            console.log("âš ï¸ modelViewer.model not available, searching alternatives...");
            
            // Shadow DOMã‹ã‚‰æ¢ã™
            const shadowRoot = modelViewer.shadowRoot;
            if (shadowRoot) {
              console.log("Found shadow root, searching for Three.js scene...");
              
              // å¯èƒ½æ€§ã®ã‚ã‚‹å†…éƒ¨ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ¢ã™
              for (let key in modelViewer) {
                try {
                  const value = modelViewer[key];
                  if (value && typeof value === 'object') {
                    console.log(`Checking modelViewer.${key}:`, typeof value, value?.constructor?.name);
                    
                    if (value.scene || value.model || (value.children && value.traverse)) {
                      model = value;
                      console.log(`âœ“ Found model via modelViewer.${key}`);
                      break;
                    }
                  }
                } catch (e) {
                  // ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                }
              }
            }
          }
          
          if (model) {
            processModelForBackface(model);
          } else {
            console.log("âŒ No model found, retrying in 2 seconds...");
            setTimeout(() => addBackfaceColorSimple(), 2000);
          }
        }, 500);
      }

      // ãƒ¢ãƒ‡ãƒ«ã®è£é¢ã‚’ã‚°ãƒ¬ãƒ¼ã«ç€è‰²
      function processModelForBackface(model) {
        console.log("Processing model for backface gray coloring...");
        console.log("Model object:", model);
        console.log("Model properties:", Object.keys(model));
        console.log("Model constructor:", model.constructor.name);
        
        let scene = null;
        
        // ã‚ˆã‚Šè©³ç´°ã«ã‚·ãƒ¼ãƒ³ã‚’æ¢ã™
        if (model.scene && typeof model.scene.traverse === 'function') {
          scene = model.scene;
          console.log("âœ“ Found scene via model.scene");
        } else if (model.children && typeof model.traverse === 'function') {
          scene = model;
          console.log("âœ“ Using model directly as scene");
        } else {
          console.log("âš ï¸ Standard scene access failed, searching deeper...");
          
          // Symbolãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’æ¢ç´¢
          const symbols = Object.getOwnPropertySymbols(model);
          console.log(`Found ${symbols.length} symbol properties:`, symbols.map(s => s.toString()));
          
          for (let symbol of symbols) {
            try {
              const value = model[symbol];
              console.log(`Checking model[${symbol.toString()}]:`, typeof value, value?.constructor?.name);
              
              if (value && typeof value === 'object' && value.traverse && typeof value.traverse === 'function') {
                scene = value;
                console.log(`âœ“ Found scene via model[${symbol.toString()}]`);
                break;
              }
              
              // é…åˆ—ã®å ´åˆã€å„è¦ç´ ã‚’ãƒã‚§ãƒƒã‚¯
              if (Array.isArray(value)) {
                console.log(`  Array with ${value.length} elements`);
                for (let i = 0; i < value.length; i++) {
                  const element = value[i];
                  console.log(`    Element [${i}]:`, typeof element, element?.constructor?.name);
                  
                  if (element && typeof element === 'object') {
                    // è¦ç´ ã®è©³ç´°ã‚’è¡¨ç¤º
                    console.log(`    Element [${i}] keys:`, Object.keys(element));
                    console.log(`    Element [${i}] symbols:`, Object.getOwnPropertySymbols(element).map(s => s.toString()));
                    
                    // traverseãƒ¡ã‚½ãƒƒãƒ‰ã‚’æŒã¤ã‹ç¢ºèª
                    if (element.traverse && typeof element.traverse === 'function') {
                      scene = element;
                      console.log(`âœ“ Found scene via model[${symbol.toString()}][${i}]`);
                      break;
                    }
                    
                    // Three.jsã®ã‚·ãƒ¼ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’æ¢ã™
                    if (element.scene && element.scene.traverse) {
                      scene = element.scene;
                      console.log(`âœ“ Found scene via model[${symbol.toString()}][${i}].scene`);
                      break;
                    }
                    
                    // ä¸€èˆ¬çš„ãªThree.jsã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚’ãƒã‚§ãƒƒã‚¯
                    const threeJsProps = ['children', 'parent', 'geometry', 'material', 'matrix', 'position', 'rotation', 'scale'];
                    for (let prop of threeJsProps) {
                      if (element[prop] !== undefined) {
                        console.log(`    Element [${i}] has Three.js property: ${prop}`);
                        
                        // childrenãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒã‚ã‚Šã€traverseãƒ¡ã‚½ãƒƒãƒ‰ã‚‚ã‚ã‚‹å ´åˆ
                        if (prop === 'children' && element.traverse && typeof element.traverse === 'function') {
                          scene = element;
                          console.log(`âœ“ Found Three.js object with traverse via model[${symbol.toString()}][${i}]`);
                          break;
                        }
                      }
                    }
                    if (scene) break;
                    
                    // è¦ç´ ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚‚å†å¸°çš„ã«æ¢ã™
                    for (let key in element) {
                      try {
                        const nestedValue = element[key];
                        if (nestedValue && typeof nestedValue === 'object' && nestedValue.traverse && typeof nestedValue.traverse === 'function') {
                          scene = nestedValue;
                          console.log(`âœ“ Found scene via model[${symbol.toString()}][${i}].${key}`);
                          break;
                        }
                      } catch (e) {
                        // ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                      }
                    }
                    if (scene) break;
                  }
                }
                if (scene) break;
              }
              
              // ãƒã‚¹ãƒˆã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚‚æ¢ã™
              if (value && typeof value === 'object') {
                // é€šå¸¸ã®ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£
                for (let nestedKey in value) {
                  try {
                    const nestedValue = value[nestedKey];
                    if (nestedValue && typeof nestedValue === 'object' && nestedValue.traverse && typeof nestedValue.traverse === 'function') {
                      scene = nestedValue;
                      console.log(`âœ“ Found scene via model[${symbol.toString()}].${nestedKey}`);
                      break;
                    }
                  } catch (e) {
                    // ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                  }
                }
                if (scene) break;
                
                // Symbolãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ã‚‚æ¢ã™
                const nestedSymbols = Object.getOwnPropertySymbols(value);
                for (let nestedSymbol of nestedSymbols) {
                  try {
                    const nestedValue = value[nestedSymbol];
                    if (nestedValue && typeof nestedValue === 'object' && nestedValue.traverse && typeof nestedValue.traverse === 'function') {
                      scene = nestedValue;
                      console.log(`âœ“ Found scene via model[${symbol.toString()}][${nestedSymbol.toString()}]`);
                      break;
                    }
                  } catch (e) {
                    // ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼ã¯ç„¡è¦–
                  }
                }
                if (scene) break;
              }
            } catch (e) {
              console.log(`Cannot access model[${symbol.toString()}]:`, e.message);
            }
          }
          
          if (!scene) {
            console.log("âŒ No traversable scene found after symbol search");
            return;
          }
        }

        let meshCount = 0;
        scene.traverse((node) => {
          if (node.isMesh && node.material) {
            meshCount++;
            console.log(`Processing mesh ${meshCount}: ${node.name || 'unnamed'}`);

            const materials = Array.isArray(node.material) ? node.material : [node.material];
            
            materials.forEach((material, index) => {
              if (material) {
                console.log(`  Modifying material ${index}: ${material.type}`);
                
                // å…ƒã®ãƒãƒ†ãƒªã‚¢ãƒ«ã‚’ä¿å­˜
                const originalSide = material.side;
                const originalOnBeforeCompile = material.onBeforeCompile;
                
                // ä¸¡é¢è¡¨ç¤ºã‚’å¼·åˆ¶çš„ã«æœ‰åŠ¹åŒ–
                material.side = 2; // THREE.DoubleSide
                
                // é€æ˜åº¦ã¨ã‚«ãƒªãƒ³ã‚°è¨­å®š
                if (material.transparent === undefined) {
                  material.transparent = false;
                }
                
                // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ä¿®æ­£ã§è£é¢ã‚’ã‚°ãƒ¬ãƒ¼ã«ï¼ˆç¢ºå®Ÿç‰ˆï¼‰
                material.onBeforeCompile = function (shader) {
                  console.log(`  Compiling shader for material ${index}`);
                  console.log(`  Original fragment shader length: ${shader.fragmentShader.length}`);
                  
                  // å…ƒã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã‚‚å®Ÿè¡Œ
                  if (originalOnBeforeCompile && typeof originalOnBeforeCompile === 'function') {
                    originalOnBeforeCompile.call(this, shader);
                  }
                  
                  // ç¢ºå®Ÿã«gl_FrontFacingãƒã‚§ãƒƒã‚¯ã‚’è¿½åŠ 
                  const backfaceCode = `
                    if (!gl_FrontFacing) {
                      gl_FragColor = vec4(0.07, 0.05, 0.05, 1.0);
                    }
                  `;
                  
                  // è¤‡æ•°ã®æŒ¿å…¥ãƒã‚¤ãƒ³ãƒˆã‚’è©¦è¡Œ
                  let modified = false;
                  
                  // 1. output_fragment ã®å¾Œ
                  if (shader.fragmentShader.includes('#include <output_fragment>')) {
                    shader.fragmentShader = shader.fragmentShader.replace(
                      /#include <output_fragment>/g,
                      `#include <output_fragment>\n${backfaceCode}`
                    );
                    modified = true;
                    console.log(`  âœ“ Applied after output_fragment`);
                  }
                  
                  // 2. mainé–¢æ•°ã®æœ€å¾Œ
                  if (!modified && shader.fragmentShader.includes('void main()')) {
                    shader.fragmentShader = shader.fragmentShader.replace(
                      /(void\s+main\s*\(\s*\)\s*{[\s\S]*?)(\s*}\s*)$/,
                      `$1${backfaceCode}$2`
                    );
                    modified = true;
                    console.log(`  âœ“ Applied at end of main()`);
                  }
                  
                  // 3. æœ€çµ‚æ‰‹æ®µï¼šã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®æœ€å¾Œ
                  if (!modified) {
                    shader.fragmentShader = shader.fragmentShader.replace(
                      /}\s*$/,
                      `${backfaceCode}\n}`
                    );
                    console.log(`  âœ“ Applied at shader end (forced)`);
                  }
                  
                  console.log(`  Modified fragment shader length: ${shader.fragmentShader.length}`);
                  
                  // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šä¿®æ­£ã•ã‚ŒãŸã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ä¸€éƒ¨ã‚’è¡¨ç¤º
                  const lines = shader.fragmentShader.split('\n');
                  console.log(`  Last 5 lines of shader:`, lines.slice(-5));
                };
                
                material.needsUpdate = true;
                console.log(`  âœ“ Material ${index} processed for gray backface (enhanced)`);
              }
            });
          }
        });

        console.log(`âœ… Processed ${meshCount} meshes with gray backface coloring`);
      }

      // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰ãƒ¢ãƒ‡ãƒ«URLã‚’å–å¾—
      function getModelUrlFromParams() {
        const urlParams = new URLSearchParams(window.location.search);
        return urlParams.get("src");
      }

      // ãƒ–ãƒ©ã‚¦ã‚¶ã®è‡ªå‹•ãƒªãƒ­ãƒ¼ãƒ‰ã‚’é˜²æ­¢
      window.addEventListener('beforeunload', (event) => {
        console.log("ğŸš¨ Page unload detected - checking if intentional...");
        
        // ãƒ¡ãƒ¢ãƒªä¸è¶³ãªã©ã§ã®æ„å›³ã—ãªã„ãƒªãƒ­ãƒ¼ãƒ‰ã‚’æ¤œå‡º
        if (performance.memory) {
          const memoryRatio = performance.memory.usedJSHeapSize / performance.memory.jsHeapSizeLimit;
          if (memoryRatio > 0.9) {
            console.error("ğŸš¨ High memory usage detected during unload:", memoryRatio);
            // ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢ã—ã¦ã‹ã‚‰å†èª­ã¿è¾¼ã¿
            localStorage.clear();
            sessionStorage.clear();
          }
        }
      });

      // ã‚¨ãƒ©ãƒ¼æ™‚ã®è‡ªå‹•ãƒªãƒ­ãƒ¼ãƒ‰ã‚’é˜²æ­¢
      window.addEventListener('error', (event) => {
        console.error("ğŸš¨ Global error detected:", event.error);
        if (event.error && event.error.message) {
          if (event.error.message.includes('memory') || 
              event.error.message.includes('quota') ||
              event.error.message.includes('storage')) {
            console.error("ğŸš¨ Memory/Storage error - preventing automatic reload");
            event.preventDefault();
            showError("Memory or storage error detected", modelViewer.src || "unknown");
          }
        }
      });

      // åˆæœŸåŒ–
      document.addEventListener("DOMContentLoaded", () => {
        console.log("ğŸš€ Page loaded, initializing...");
        updateBackgroundColor();
        
        // æœ€å¤§åŒ–ãƒœã‚¿ãƒ³ã®hrefã‚’ç¾åœ¨ã®URLã§æ›´æ–°
        const maximizeButton = document.getElementById("maximizeButton");
        if (maximizeButton) {
          maximizeButton.href = window.location.href;
        }

        // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã«ãƒ¢ãƒ‡ãƒ«URLãŒã‚ã‚Œã°èª­ã¿è¾¼ã¿
        const modelUrl = getModelUrlFromParams();
        if (modelUrl) {
          console.log("ğŸ“¥ Loading model from URL parameter:", modelUrl);
          loadSampleModel(modelUrl);
        } else {
          console.log("ğŸ” No URL parameter, checking default model...");
          // default.glbãŒå­˜åœ¨ã—ãªã„å ´åˆã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
          checkDefaultModel();
        }
        
        // 5åˆ†å¾Œã«å¼·åˆ¶çš„ã«ã‚¨ãƒ©ãƒ¼ç”»é¢ã‚’è¡¨ç¤ºï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
        setTimeout(() => {
          if (!modelViewer.model && customProgressBar.style.display !== "none") {
            console.error("ğŸš¨ Force timeout after 5 minutes");
            showError("Loading took too long - please try again", modelViewer.src || "unknown");
          }
        }, 300000);
      });

      // default.glbã®å­˜åœ¨ãƒã‚§ãƒƒã‚¯
      async function checkDefaultModel() {
        try {
          const response = await fetch("./default.glb", { method: "HEAD" });
          if (response.ok) {
            // default.glbãŒå­˜åœ¨ã™ã‚‹å ´åˆ
            console.log("Loading default.glb");
            modelViewer.src = "./default.glb";
          } else {
            // default.glbãŒå­˜åœ¨ã—ãªã„å ´åˆã€Arweaveã®ãƒ¢ãƒ‡ãƒ«ã‚’ä½¿ç”¨
            console.log("default.glb not found, using fallback model");
            modelViewer.src =
              "https://arweave.net/ZFDOSKBnBnAlHx4olZjFEAQpPgO0UigLHrzXw-bds6k";
          }
        } catch (error) {
          // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã¾ãŸã¯ãƒ•ã‚¡ã‚¤ãƒ«ãŒå­˜åœ¨ã—ãªã„å ´åˆ
          console.log("default.glb not accessible, using fallback model");
          modelViewer.src =
            "https://arweave.net/ZFDOSKBnBnAlHx4olZjFEAQpPgO0UigLHrzXw-bds6k";
        }
      }

      // å¤–éƒ¨ã‚¯ãƒªãƒƒã‚¯ã§ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒ‘ãƒãƒ«ã‚’é–‰ã˜ã‚‹
      document.addEventListener("click", (e) => {
        if (
          !lightControls.contains(e.target) &&
          !lightControlButton.contains(e.target)
        ) {
          if (showControls) {
            showControls = false;
            lightControls.style.display = "none";
          }
        }
      });
    </script>
  </body>
</html>
